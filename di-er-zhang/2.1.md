# 2.1 MDK下C语言基础复习

这一节我们主要讲解一下C 语言基础知识。 C 语言知识博大精深，也不是我们三言两语能讲解清楚，同时我们相信学 STM32F4 这种级别 MCU 的用户， C 语言基础应该都是没问题的。我们这里主要是简单的复习一下几个 C 语言基础知识点，引导那些 C 语言基础知识不是很扎实的用户能够快速开发 STM32 程序。同时希望这些用户能够多去复习一下 C 语言基础知识， C 语言毕竟是单片机开发中的必备基础知识。对于 C 语言基础比较扎实的用户，这部分知识可以忽略不看。(对C语言已经有一些基础的,可以浏览一遍,在之后的开发中多加练习,便会掌握这些用法.不必一直纠结在于第一章)

## 2.1.1 位操作

语言位操作相信 学过 C 语言的人都不陌生了 简而言之，就是对基本类型变量可以在位级 别进行操作。这节的内容很多朋友都应该很熟练了，我这里也就点到为止，不深入探讨。下面 我们先讲解几种位操作符，然后讲解位操作使用技巧。\
C语言支持如下 6 种位操作

| 运算符 |  含义  | 运算符 |  含义 |
| :-: | :--: | :-: | :-: |
|  &  |  按位与 |  \~ |  取反 |
|  \| |  按位或 |  << |  左移 |
|  ^  | 按位异或 |  >> |  右移 |

这些与或非，取反，异或，右移，左移这些到底怎么回事，这里我们就不多做详细，相信大家学 C 语言的时候都学习过了。如果不懂的话，可以搜索一下，非常多的知识讲解这些操作符。下面我们想着重讲解位操作在单片机开发中的一些实用技巧。

## 2.1.2 实用技巧

### 不改变其他位的值的状况下，对某几个位进行设值。

这个场景单片机开发中经常使用，方法就是先对需要设置的位用**&**操作符进行清零操作，然后用**|**操作符设值。比如我要改变GPIOA->ODR的状态,可以先对寄存器的值进行**&**清零操作

`GPIOA->ODR &=0XFF0F; //将第4-7位清0`

然后再与需要设置的值进行|或运算

`GPIOA->ODR |=0X0040;//设置相应位的值，不改变其他位的值`

### 移位操作提高代码的可读性

移位操作在单片机开发中也非常重要，我们来看看下面一行代码

`GPIOA->ODR |= 1 << 5; // 此处为先左移后或`

这个操作就是将ODR寄存器的第5位设置为1，为什么要通过左移而不是直接设置一个固定的值呢？其实，这是为了提高代码的可读性以及可重用性。这行代码可以很直观明了的知道，是将第5位设置为1，其他位的值不变。如果你写成

`GPIOA->ODR =0x0020;`

这样的代码可读性非常差同时也不好重用。

### \~取反操作使用技巧

例如GPIOA->ODR寄存器的每一位都用来设置一个IO口的输出状态，某个时刻我们希望去设置某一位的值为0，同时其他位都为1，简单的作法是直接给寄存器设置一个值：

`GPIOA->ODR =0xFFF7；`

这样的作法设置第3位为0，但是这样的写法可读性很差。看看如果我们使用取反操作怎么实现：

`GPIOA->ODR= (uint16_t)~(1<<3);`

看这行代码应该很容易明白，我们设置的是ODR寄存器的第3位为0，其他位为1，可读性非常强。

## 2.1.3 define宏定义

**define**是C语言中的预处理命令，它用于宏定义，可以提高源代码的可读性，为编程提供方便。常见的格式：

`#define 标识符 字符串`

“标识符”为所定义的宏名。“字符串”可以是常数、表达式、格式串等。例如：

`#define HSI_VALUE ((uint32_t)16000000)`

定义标识符**HSI\_VALUE的值为16000000**。这样我们就可以在代码中直接使用标识符HSI\_VALUE，而不用直接使用常量**1600000**，同时也很方便我们修改**HSI\_VALUE**的值。 至于define宏定义的其他一些知识，比如宏定义带参数这里我们就不多讲解。

## 2.1.4 #ifdef和 #if defined条件编译

单片机程序开发过程中，经常会遇到一种情况，当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。条件编译命令最常见的形式为：

```c
#ifdef 标识符 
程序段1 
#else 程序段2 
#endif
```

它的作用是：当标识符已经被定义过(一般是用 #define 命令定义 )，则对程序段 1 进行编译，否则编译程序段 2 。 其中 #else 部分也可以没有，即：

```c
#ifdef 
    程序段 1 
#endif
```

这个条件编译在MDK 里面是用得很多的，在 stm32f4xx\_hal\_conf.h 这个头文件中会看到这样的语句：

```c
#ifdef HAL_GPIO_MODULE_ENABLED 
    #include "stm32f1xx_hal_gpio.h" 
#endif
```

这段代码的作用是判断宏定义标识符**HAL\_GPIO\_MODULE\_ENABLED**是否被定义， 如果被定义了，那么就引入头文件**stm32f1xx\_hal\_gpio.h**。\
对于条件编译，还有个常用的格式，如下：

```c
#if defined XXX1 
    程序段 1 
#elif defined XXX2 
    程序段 2
#elif defined XXXn 
    程序段 n
#endif
```

这种写法的作用实际跟ifdef 很相似，不同的是 ifdef 只能在两个选择中判断是否定义，而 if defined 可以在多个选择中判断是否定义。条件编译也是c 语言的基础知识，这里就给大家讲解到这里，不懂的大家可以查看在网上搜索相关资料学习。

## 2.1.4 extern变量申明

C语言中 extern可以置于变量或者函数前，以表示变量或者函数的定义在别的文件中(外部变量)，提示编译器遇到此变量和函数时在其他模块中寻找其定义 。这里面要注意，对于 extern 申明变量可以多次，但定义只有一次。在我们的代码中你会看到看到这样的语句：

`extern u16 USART_RX_STA;`

这个语句是申明USART\_RX\_STA变量在其他文件中已经定义了，在这里要使用到。所以，你肯定可以找到在某个地方有变量定义的语句：

`u16 USART_RX_STA;`

下面通过一个例子说明一下使用方法。\
在main.c定义的全局变量id，id的初始化都是在main.c里面进行的。

main.c文件

```c
uint8_t id;//定义只允许一次
main() 
{ 
    id=1; 
    printf("d%",id);//id=1 
    test(); 
    printf("d%",id);//id=2 
}
```

但是我们希望在test.c的 **changeId(void)**函数中使用变量**id**,这个时候我们就需要在test.c里面去申明变量**id**是外部定义的了，因为如果不申明，变量**id**的作用域是到不了test.c文件中。看下面test.c中的代码：

```c
extern uint8_t id;//申明变量id是在外部定义的，申明可以在很多个文件中进行
void test(void)
{ 
    id=2;
}
```

在test.c中申明变量id在外部定义，然后在test.c中就可以使用变量id了。 对于extern申明函数在外部定义的应用，这里我们就不多讲解了

## 2.1.5 typedef类型别名

typedef用于为现有类型创建一个新的名字，或称为类型别名，用来简化变量的定义。typedef在MDK用得最多的就是定义结构体的类型别名和枚举类型了。

```c
struct _GPIO 
{
    __IO uint32_t MODER;
    __IO uint32_t OTYPER; 
    … 
};
```

定义了一个结构体GPIO，这样我们定义变量的方式为：

`struct _GPIO GPIOA;//定义结构体变量 GPIOA`

但是这样很繁琐，MDK中有很多这样的结构体变量需要定义。这里我们可以为结体定义一个别名GPIO\_TypeDef，这样我们就可以在其他地方通过别名GPIO\_TypeDef来定义结构体变量了。方法如下：

```c
typedef struct 
{
    __IO uint32_t MODER;
    __IO uint32_t OTYPER;
    … 
} GPIO_TypeDef;
```

## 2.1.6 结构体

Typedef为结构体定义一个别名GPIO\_TypeDef，这样我们可以通过GPIO\_TypeDef来定义结构体变量：

`GPIO_TypeDef _GPIOA,_GPIOB;`

这里的GPIO\_TypeDef就跟struct GPIO是等同的作用了。 这样是不是方便很多？

经常很多用户提到，他们对结构体使用不是很熟悉，但是MDK中太多地方使用结构体以及结构体指针，这让他们一下子摸不着头脑，学习STM32的积极性大大降低，其实结构体并不是那么复杂，这里我们稍微提一下结构体的一些知识，还有一些知识我们会在下一节的“寄存器 地址名称映射分析”中讲到一些。

声明结构体类型：

```c
Struct 结构体名
{ 
    成员列表;
}变量名列表；
```

例如：

```c
Struct G_TYPE 
{ 
    uint32_t Pin;
    uint32_t Mode; 
    uint32_t Speed; 
}GPIOA，GPIOB;
```

在结构体申明的时候可以定义变量，也可以申明之后定义，方法是：

`Struct 结构体名字 结构体变量列表 ;`

例如：struct G\_TYPE GPIOA,GPIOB;

结构体成员变量的引用方法是：

`结构体变量名字.成员名`

比如要引用GPIOA的成员Mode，方法是：GPIOA. Mode;\
结构体指针变量定义也是一样的，跟其他变量没有啥区别。\
例如：struct G\_TYPE \*GPIOC；//定义结构体指针变量GPIOC;\
结构体指针成员变量引用方法是通过“->”符号实现，比如要访问GPIOC结构体指针指向的结构体的成员变量Speed,方法是：

`GPIOC-> Speed;`

上面讲解了结构体和结构体指针的一些知识，其他的什么初始化这里就不多讲解了。讲到这里，有人会问，结构体到底有什么作用呢？为什么要使用结构体呢？下面我们将简单的通过一个实例回答一下这个问题。\
在我们单片机程序开发过程中，经常会遇到要初始化一个外设比如IO口。它的初始化状态是由几个属性来决定的，比如模式，速度等。对于这种情况，在我们没有学习结构体的时候， 我们一般的方法是：

`void HAL_GPIO_Init (uint32_t Pin, uint32_t Mode, uint32_t Speed);`

这种方式是有效的同时在一定场合是可取的。但是试想，如果有一天，我们希望往这个函数里面再传入一个参数，那么势必我们需要修改这个函数的定义，重新加入上下拉Pull这个入口参数。于是我们的定义被修改为：

`void HAL_GPIO_Init (uint32_t Pin, uint32_t Mode, uint32_t Speed,uint32_t Pull);`

但是如果我们这个函数的入口参数是随着开发不断的增多，那么是不是我们就要不断的修改函数的定义呢？这是不是给我们开发带来很多的麻烦？那又怎样解决这种情况呢？

这样如果我们使用到结构体就能解决这个问题了。我们可以在不改变入口参数的情况下，只需要改变结构体的成员变量，就可以达到上面改变入口参数的目的。

结构体就是将多个变量组合为一个有机的整体。上面的函数中Pin, Mode, Speed和Pull这些参数，他们对于GPIO而言，是一个有机整体，都是来设置IO口参数的，所以我们可以将他们通过定义一个结构体来组合在一个。MDK中是这样定义的：

```c
typedef struct 
{
    uint32_t Pin; 
    uint32_t Mode; 
    uint32_t Pull;
    uint32_t Speed; 
}GPIO_InitTypeDef;
```

于是，我们在初始化GPIO口的时候入口参数就可以是GPIO\_InitTypeDef类型的变量或者指针变量了，MDK中是这样做的：

`void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init);`

这样，任何时候，我们只需要修改结构体成员变量，往结构体中间加入新的成员变量，而不需要修改函数定义就可以达到修改入口参数同样的目的了。这样的好处是不用修改任何函数定义就可以达到增加变量的目的。

理解了结构体在这个例子中间的作用吗？在以后的开发过程中，如果你的变量定义过多，如果某几个变量是用来描述某一个对象，你可以考虑将这些变量定义在结构体中，这样也许可以提高你的代码的可读性。

使用结构体组合参数，可以提高代码的可读性，不会觉得变量定义混乱。当然结构体的作用就远远不止这个了，同时，MDK中用结构体来定义外设也不仅仅只是这个作用，这里我们只是举一个例子，通过最常用的场景，让大家理解结构体的一个作用而已。后面一节我们还会讲解结构体的一些其他知识。
