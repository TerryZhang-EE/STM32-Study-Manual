# 3.3 定时器中断实验

这一章 ，我们将向大家介绍如何使用 STM32的基本定时器， STM32的定时器功能十分强 大，有 TIME1和 TIME8等高级定时器，也有 TIME2\~TIME5等通用定时器，还有 TIME6和 TIME7等基本定时器。

在《 STM32参考手册》里面，定时器的介绍占了 1/5的篇幅，足见其重要性。 在本章中，我们将使用 TIM6的定时器中断来控制 DS0的翻转。本章，我们选择难度较低的基本定时器来介绍， 本章将 分为如下几个部分：

* 硬件设计
* 软件设计
* 下载验证

## 3.3.1 硬件设计

本实验用到的硬件资源有：\
1\. 指示灯 DS0\
2\. 定时器 TIM6

本章 将通过 TIM6的中断来实现DS0的闪灯效果， DS0和 DS1的电路在前面已经有介绍了。而 TIM6属于 STM32的内部资源，只需要软件设置即可正常工作。

## 3.3.2 软件设计

### 创建工程

创建工程本篇不再赘述, 如果有不会创建工程的读者, 请重复阅读 **3.1 跑马灯实验**

### 配置芯片

1. 配置**RCC**, 配置**SYS**与**3.1 跑马灯实验** 相同, 所以本篇不再赘述
2. 根基实际情况配置时钟, (STM32F103x的最高主频是72M )，如下图

![](../.gitbook/assets/2021-08-18-16-24-01.png)

1. 设置定时器, 启用TIM6，选择内部时钟源（Internal Clock）。

![](../.gitbook/assets/2021-08-18-16-32-21.png)

1.  设置 预分频系数与重装载值 &#x20;

    我们在此处设置为7200-1 与 10-1 &#x20;

    设置 预分频系数与重装载值 是为了控制定时器触发中断的时间(也就是周期)&#x20;

具体详解,因篇幅所限,请自行查询相关资料, 我们在这里提供一个计算方法

假设, 我们需要500ms触发一次中断, 则周期为500ms=0.5s\
我们为了方便计算将周期转换为频率, 所以 频率 = 1 / 0.5s = 2Hz\
我们的时钟频率为72MHz, 得出 72M / ? / ? = 2\
注: 两个?所代表的值均不能大于65535\
通常, 我们将第一个? 设置为 7.2KHz\
即 72M / 7.2K / ? = 2 , 即 10K / ? = 2 故, 第二个?为5k

**得, 预分频系数(Prescaler-PSC)为7200 - 1, 重装载值(Counter Period)为5000 - 1**

![](../.gitbook/assets/2021-08-18-16-42-11.png)

1. 配置DS0所对应的GPIO, 因已经在3.1篇讲解过,故本处不再赘述.
2. 接下来就是生成工程等步骤, 具体同3.1篇

### 编写程序

1. 寻找定时器中断回调函数&#x20;

点击+展开tim.c文件查看该文件下面的函数 如图:

![](../.gitbook/assets/2021-08-18-18-36-33.png)

1. 我们下拉找到**Callback**相关函数

![](../.gitbook/assets/2021-08-18-18-44-16.png)

\_\_weak 表示弱定义, 具体的解释如下:

该关键字用于函数前，编译器在链接函数时会优先链接没有该关键字前缀的函数，即变相的，而且是不完全的实现了C++的函数重载特性，示例：

```c
//HAL库微秒延时函数，有__weak关键字即代表可以重载该函数
__weak HAL_Delay(__IO uint32_t delay);
//用户函数
HAL_Delay(__IO uint32_t delay);
```

以上两个函数，编译器会优先链接下面的函数，即为我们重定义延时函数提供了较大的便利性。

1. 添加一个变量用来储存系统时间

```c
uint32_t millis;
uint32_t last_time;
```

![](../.gitbook/assets/2021-08-18-22-15-39.png)

1.  重写定时器中断回调函数 &#x20;

    因为TIM6每1ms触发一次一次中断, 所以可以将millis的值作为系统时间 &#x20;

    具体代码如下:&#x20;

```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if (TIM6 == htim->Instance) //判断中断是否是TIM6触发
    {
        millis++; //每1ms自增一次
    }
}
```

![](../.gitbook/assets/2021-08-18-22-20-07.png)

1. 添加主要代码

程序流程图, 如下:

![](../.gitbook/assets/2021-08-20-02-18-32.png)

具体代码如下:

```c
HAL_TIM_Base_Start_IT(&htim6);
```

![](../.gitbook/assets/2021-08-20-16-11-00.png)

```c
if(millis - last_time >= 500) //millis计数到500表示已经过去了0.5秒
{
    last_time = millis; //记录下当前的时间, 防止单位时间内多次进入
    HAL_GPIO_TogglePin(LED0_GPIO_Port,LED0_Pin); //翻转LED0_Pin引脚的电压
}
```

![](../.gitbook/assets/2021-08-18-22-29-49.png)

## 3.3.3 下载验证

编写完工程后我们点击编译,等待编译完成后进行下载.\
下载完成后,我们按下开发板上的复位按钮后可以看到, 开发板上的D0亮500ms灭500ms

![](../.gitbook/assets/2021-08-18-16-01-27.png)

为什么要使用定时器计数方法来闪灯?\
因为3.1中的Delay闪灯方法中的Delay是会导致单片机进入一个假死机的状态, 导致无法进行其他事件的处理.例如按键控制闪灯等.

**练习 3.3 : 使用WK\_UP切换LED灯闪烁模式, KEY0与KEY1 控制 LED灯的闪烁速度**
